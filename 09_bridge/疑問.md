## メモ
- ブリッジパターンは機能と実装をわけるパターン
- 機能クラスの階層：SomethingクラスのサブクラスでSomethingGood、みたいな
- 実装クラスの階層：
  - 一連の流れを抽象クラスでIF定義してあげる
  - 機能追加じゃなくて、実際の処理が増えて行く感じ
- この2つをわけて実装を進める

## 説明2
- Displayが機能
  - コンストラクタにimplのインスタンスを渡す
  - このインスタンスを使うので、このインスタンスをもったフィールドが「橋」
  - Displayが持つメソッドは表示の手順を表す

## 疑問
- displayがrawopenを呼び出す
- openをもってたほうがいい？名前的な意味で（実装と機能のクラスのメソッド名揃える）
  - 勉強会メモのように、名前はちがっていい
- displayはabstractではない？
  - 勉強会メモのよう参照
- __init__って返り値ありうる？初期設定だからなさそうだけど
  - ない！
  - フィールド変数に入れるだけ
- mainがDisplayの機能と、Displayの実際の中身を選ぶって感じ？？
  - そう
- たまねぎみたいで処理をおうのが大変そう
  - 抽象のところに大まかな流れが描かれているはず
  - reactとかだと処理の流れがなくて、ユーザのイベントに対しての動きが定義されているから読みにくいかも
　
## 勉強会メモ
- adapterパターンと同じような考え方
  - clientから古いIFを呼びたい
  - アダプタクラスでinputをclientの出力、outをIFのinに合わせる
  - 機能がアダプタ（何も持っていないけど呼び出すだけ）、実装が古いIFみたいな
  - だからアダプタ（機能）はabstractじゃない
  - アダプタだけを返すときもある（拡張は見せたくない時）
- これの考え方は「スコープ」について。なるべく狭くしてあげる
  - メソッドを狭くするとか
  - IFの見える範囲を狭めるのもスコープ
  - 最初にIFって決めるからわかる。決まってるものに追加するからこういう設計
- 最初adapterでやってみて、弱かったらbridgeみたいな感じ！